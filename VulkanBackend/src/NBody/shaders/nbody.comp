#version 450

#define BODIES_COUNT 7

// STEP_LENGTH is how many second every simulation step
#define STEP_LENGTH 3600

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

const double G = 6.674 * pow(10, -11);

struct Body {
	dvec3 position;
	dvec3 last_position;
	dvec3 velocity;
	double mass;
};

layout (set = 0, binding = 0) buffer buf_block {
	Body bodies[BODIES_COUNT];
};



void iterate(uint index, float step_length) 
{
	dvec3 force = dvec3(0, 0, 0);

	// iterate all other bodies
	for ( int i = 0; i < BODIES_COUNT; ++i )
	{
		// skip for itself
		if ( i == index ) 
			continue;

		dvec3 direction = bodies[i].last_position - bodies[index].position;
		double r = length(direction);
		double f = (G * bodies[index].mass * bodies[i].mass) / (r * r);

		//// costly calculation
		//double cosPhi = dot(direction, vec3(1, 0, 0)) / r;
		//double cosTheta = dot(direction, vec3(0, 0, 1)) / r;
		//double sinTheta = sqrt(1 - (cosTheta * cosTheta));
		//double sinPhi = sqrt(1 - (cosPhi * cosPhi));
		//double x = f * sinTheta * cosPhi;
		//double y = f * sinTheta * sinPhi;
		//double z = f * cosTheta;
		//
		//if (direction.y < 0.f)
		//	y = -y;
		////

		force += (G * bodies[index].mass * bodies[i].mass) / (r * r) * normalize(direction);
	}

	dvec3 dp = step_length * force;
	dvec3 dv = dp / bodies[index].mass;
	bodies[index].velocity += dv;
	bodies[index].position += bodies[index].velocity * step_length;
}

void main() {
	// index for itself
	uint index = gl_GlobalInvocationID.x;

	if(index > 6)
		return;

	iterate(index, STEP_LENGTH);
}